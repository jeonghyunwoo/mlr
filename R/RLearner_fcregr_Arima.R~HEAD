#'@export
makeRLearner.fcregr.Arima = function() {
  makeRLearnerRegr(
    cl = "fcregr.Arima",
    package = "forecast",
    par.set = makeParamSet(
      makeIntegerVectorLearnerParam(id = "order", len = 3L,
                                    lower = 0L, upper = Inf,
                                    default = c(0L,0L,0L),
                                    tunable = TRUE),
      makeIntegerVectorLearnerParam(id = "seasonal", len = 3L,
                                    lower = 0L, upper = Inf,
                                    default = c(0L,0L,0L),
                                    tunable = TRUE),
      makeLogicalLearnerParam(id = "include.mean", default = TRUE, tunable = TRUE),
      makeLogicalLearnerParam(id = "include.drift", default = FALSE, tunable = TRUE),
      makeNumericLearnerParam(id = "lambda", default = 1, tunable = TRUE, special.vals = list(NULL)),
      makeDiscreteLearnerParam(id = "method", values = c("CSS-ML", "ML", "CSS"),
                               default = "CSS-ML", tunable = FALSE),
      # Make prediction parameters
      makeNumericLearnerParam(id = "n.ahead", lower = 1, upper = Inf,
                       default = 1, when = "predict"),
      makeLogicalLearnerParam(id = "se.fit", default = FALSE, tunable = FALSE),
      makeUntypedLearnerParam(id = "xreg", default = NULL)
    ),
    properties = c("numerics","ts"),
    name = "AutoRegressive Integrated Moving Average",
    short.name = "Arima",
    note = ""
    )
}

#'@export
trainLearner.fcregr.Arima = function(.learner, .task, .subset, .weights = NULL, ...) {

  data = getTaskData(.task,.subset, target.extra = TRUE)
  data$target = ts(data$target, start = 1, frequency = .task$task.desc$frequency)
  forecast::Arima(y = data$target, ...)
}

#'@export
predictLearner.fcregr.Arima = function(.learner, .model, .newdata, ...){
  #TODO: Allow std errors to return as well
  predict(.model$learner.model, ...)$pred
}


